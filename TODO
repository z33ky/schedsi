* weighted round robin (deficit round robin?)
	* seems to be the basis of the most popular general purpose OS schedulers
* dynamic hierarchy
	* there should be no assumptions at the moment that the module hierarchy or thread queues are fixed, so all that's missing is a nice interface or helper functions/classes
	* perhaps names for modules and tids for threads should be optional and auto-generated if not supplied, just following the convention used in the kernel.py example
* multi-core
	* thanks to the recent re-architecturing this should be implementable fairly easily
	* does this work without supporting multiple VCPUs per module?
		* since in the current hierarchical scheduling approach VCPUThreads are essentially checkpointed threads
		  that start from the checkpoint each time they are invoked, running a single VCPUThread multiple times from multiple core seems conceptually sound
		* scheduling data is protected against concurrent access, thread data access would need the same approach
		* (currently locking the mutex of the running VCPUThread would fail and trigger an assert)
		* the CPU analogy breaks down though
* support multiple VCPUs per module
	* easy: sort threads to VCPUs on creation
		* could also use run-time balancing
	* advanced: mutli-core aware schedulers
* run-time balancing of threads between schedulers
	* schedulers need support to remove threads from their queue
		* the schedulers should probably decide themselves which thread to pass on
	* need a dedicated thread to do this balancing
		* or integrate into scheduler
* external interrupts
	* also thanks to the recent re-architecturing this should be implementable fairly easily
	* basically we just want to jump back to the kernel to "handle" some interrupts
* simulate message-passing
	* synchronous message-passing should be the most interesting thing here, since it puts threads to sleep until the message round-tripped back and wakes it again
* aggregate statistics
	* various statistics are being recorded (we may want to think about what else we can record, too)
	* these should be logged and presented at least for the binary log and text log
	* the graph log could plot some fancy distributions
* static hierarchy builder
	* the current approach is a bit inconvenient
	* we want automatic name generation and VCPU additions
